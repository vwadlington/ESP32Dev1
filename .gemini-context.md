# Gemini Project Context: ESP32-S3 Smart Home Controller

## 1. Project Identity & Hardware
- **Target Device:** ESP32-S3-LCD-EV-Board2 (Espressif)
- **Display Module:** Sub-board 3 (800x480 RGB interface)
- **Touch Controller:** GT1151
- **Storage:** 16MB Flash with a dedicated SPIFFS partition labeled `storage`.
- **Framework:** ESP-IDF v5.1+ (C Language)
- **UI Library:** LVGL v9.x (Strict adherence to v9 APIs).

## 2. Component Architecture & Rules

### A. minigui (UI Component)
* **Path:** `components/minigui/` (Standalone GitHub Repo)
* **Screen Management:** Non-persistent loading.
    * The `status_bar` and `content_area` are persistent.
    * When `minigui_switch_screen` is called, children of the content area must be cleared via `lv_obj_clean(content_area)` before the new screen is allocated to save RAM.
* **Layering:** Global UI elements (Hamburger menu, Navigation drawer) must reside on `lv_layer_top()`.
* **Hardware Decoupling:** `minigui` does not call BSP drivers directly. It uses a callback system (e.g., `minigui_brightness_cb_t`) registered in `main.c`.

#### **Architecture & Layout**
* **Root Structure:** Use a Vertical Flex Column (`main_container`) as the global wrapper.
    * **Row 1 (Status Bar):** Horizontal Flex Row. Fixed height or `lv_pct(12)`.
    * **Row 2 (Content Area):** Use `lv_obj_set_flex_grow(content_area, 1)` to fill all remaining vertical space.
* **Drawer Logic:** The navigation menu must be parented to `lv_layer_top()` so it overlays the persistent Status Bar and Content Area.
* **Square Constraints:**
    * **Radius:** Force `lv_obj_set_style_radius(obj, 0, 0)` on the Main Container, Status Bar, and Content Area to prevent background bleed-through.
    * **Buttons:** The Hamburger menu button must be a 1:1 square. Implement this via `LV_EVENT_SIZE_CHANGED` with a callback that sets `width` equal to the parent's calculated `height`.



#### **LVGL 9.4 Implementation Standards**
* **Logging:** Use `LV_LOG_INFO`, `LV_LOG_WARN`, and `LV_LOG_ERROR` directly. Do not include `esp_log.h` or use `ESP_LOGx` macros to maintain board-agnosticism.
* **Flex Reset:** When switching screens, use `lv_obj_set_style_flex_flow(obj, 0, 0)` to clear layout settings (Note: `LV_FLEX_FLOW_NONE` is not defined in this environment).
* **Screen Swapping:** Always call `lv_obj_clean(content_area)` before applying new layout flows or creating new child objects.

#### **Typography (STRICT)**
* Only the following fonts are available in the manifest. Do not use other sizes:
    * **Montserrat 14:** Body text, button labels, table data (Logs).
    * **Montserrat 28:** Screen titles (Status Bar) and section headers.
    * **Montserrat 48:** Hero numbers (Sensor values, large clocks).

### B. dlogger (Logging Component)
- **Path:** `components/dlogger/`
- **Functionality:** Unified stream for `ESP_LOG` and `LVGL_LOG`.
- **Storage Strategy:** Circular rotation of 2 files, max 1MB each.
- **Format:** Timestamps generated via `esp_timer_get_time()` for file naming.

### C. storage (Storage Component)
- **Path:** `components/storage/`
- **Mount Point:** `/storage` (SPIFFS).

## 3. Directory Structure
```text
.
├── components
│   ├── dlogger
│   │   ├── dlogger.c/h
│   │   └── CMakeLists.txt
│   ├── minigui
│   │   ├── include/minigui.h
│   │   ├── include/screens/ (screen_home.h, screen_logs.h, screen_settings.h)
│   │   ├── src/minigui.c
│   │   └── src/screens/ (screen_home.c, screen_logs.c, screen_settings.c)
│   └── storage
│       └── storage.c/h
├── main
│   ├── main.c
│   └── idf_component.yml
└── partitions.csv

## 4. Interaction Constraints
- **Thread Safety:** LVGL is not thread-safe. All GUI modifications (screen switches, widget updates) must be performed while holding the `bsp_display_lock()` or within the LVGL timer task.
- **V9 Handler Signature:** In LVGL v9, the log callback signature is strictly `void func(lv_log_level_t level, const char *buf)`. Do not use the deprecated v8 signature which included file/line/function parameters.
- **Memory Monitoring:** Always consider PSRAM vs SRAM. Large buffers (like the upcoming log ring buffer) should be heap-allocated, ideally in PSRAM if the hardware configuration allows.
- **Build Awareness:** Ignore `build/`, `managed_components/`, and `.git/` directories during context analysis; focus exclusively on source code and headers.
- **Error Handling:** Every file-system operation (SPIFFS) or memory allocation must include a null-check or `esp_err_t` validation.
- **Comments:** Don't delete all the comments during a code edit. Keep as many comments as possible when editing code.

5. Component Architecture: Data Flow & Dependencies
A. Layered Architecture (STRICT)
The system follows a strict layered architecture with clean separation of concerns:

text
┌─────────────────────────────────────────────────────────┐
│                    UI Layer (minigui)                    │
│  • LVGL widget creation & management                    │
│  • Screen layouts & styling                             │
│  • User interaction handling                            │
│  • NO business logic or data processing                 │
└─────────────────┬───────────────────────────────────────┘
                  │ (Formatted data via callbacks/structs)
┌─────────────────▼───────────────────────────────────────┐
│                Bridge Layer (app_bridge)                 │
│  • Converts raw data to UI-friendly formats             │
│  • Provides data to UI via clean interfaces             │
│  • Handles data transformations & filtering             │
│  • NO direct LVGL widget manipulation                   │
└─────────────────┬───────────────────────────────────────┘
                  │ (Raw data via APIs)
┌─────────────────▼───────────────────────────────────────┐
│                Data Layer (dlogger/storage)             │
│  • Data collection & storage only                       │
│  • No knowledge of UI frameworks                        │
│  • Provides raw data APIs (no formatting)               │
│  • Platform-agnostic (works without LVGL/ESP)           │
└─────────────────────────────────────────────────────────┘
B. Data Flow Rules (MANDATORY)
Unidirectional Flow: Data flows UP (Data → Bridge → UI), events flow DOWN (UI → Bridge → Data)

No Cross-Layer Dependencies:

UI layer cannot include data layer headers

Data layer cannot include UI headers

Bridge acts as adapter between layers

Interface-Based Communication:

UI ↔ Bridge: Structured data via callbacks or structs

Bridge ↔ Data: Raw data via function APIs

No Widget Manipulation Outside UI Layer: Only minigui/ and its screens may call LVGL widget functions.

C. Logging System Architecture
text
┌─────────────┐    logs     ┌─────────────┐    raw data    ┌─────────────┐
│   ESP/LVGL  │────────────►│   dlogger   │───────────────►│   storage   │
│   Sources   │             │  (collect)  │               │   (file)    │
└─────────────┘             └──────┬──────┘               └─────────────┘
                                   │ raw data APIs
                            ┌──────▼──────┐
                            │  app_bridge │
                            │  (format)   │
                            └──────┬──────┘
                                   │ formatted structs
                            ┌──────▼──────┐
                            │ screen_logs │
                            │  (display)  │
                            └─────────────┘
D. Component Responsibilities
dlogger (Data Layer - PURE)
DOES: Collect logs from various sources (ESP, LVGL, USER)

DOES: Store logs in circular buffer and file

DOES: Provide raw data access APIs

DOES NOT: Format logs for display

DOES NOT: Know about LVGL or UI frameworks

DOES NOT: Directly manipulate UI widgets

app_bridge (Bridge Layer - ADAPTER)
DOES: Convert raw log data to display-ready formats

DOES: Provide filtered, formatted data to UI

DOES: Handle data transformations

DOES NOT: Create or manipulate LVGL widgets

DOES NOT: Contain business logic

DOES NOT: Store data permanently

minigui/screens (UI Layer - PRESENTATION)
DOES: Create and manage LVGL widgets

DOES: Handle user interactions and events

DOES: Display formatted data from bridge

DOES NOT: Process raw data

DOES NOT: Directly access data layer

DOES NOT: Contain data transformation logic

E. Violations to Fix in Current Codebase
None. The codebase currently aligns with the defined architectural rules.

F. Correct Interface Definitions
Data Layer API (dlogger.h):
c
// PURE data structures - no formatting
typedef struct {
    uint32_t timestamp;
    uint8_t source;      // LOG_SOURCE_ESP/LVGL/USER
    uint8_t level;       // LOG_LEVEL_ERROR/WARN/INFO/DEBUG
    char message[188];   // Raw message
} raw_log_entry_t;

// Raw data APIs only
esp_err_t dlogger_get_raw_entries(raw_log_entry_t *dest, size_t max_entries);
size_t dlogger_get_raw_entry_count(void);
Bridge Layer API (app_bridge.h):
c
// Formatted/processed data for UI
typedef struct {
    char timestamp[16];  // Formatted: "12345678"
    char source[8];      // Formatted: "ESP", "LVGL", "USER"
    char level[2];       // Formatted: "E", "W", "I", "D"
    char message[100];   // Truncated/cleaned message
} formatted_log_entry_t;

// Bridge APIs - data transformation only
size_t app_bridge_get_formatted_logs(formatted_log_entry_t *logs, 
                                     size_t max_logs, 
                                     const char *filter);
UI Layer (Uses bridge API):
c
// In screen_logs.c - only UI logic
formatted_log_entry_t logs[20];
size_t count = app_bridge_get_formatted_logs(logs, 20, "ALL");
for (size_t i = 0; i < count; i++) {
    lv_table_set_cell_value(table, i, 0, logs[i].timestamp);
    // ... UI display only
}
--- END ADDITION TO .gemini-context.md ---